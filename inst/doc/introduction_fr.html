<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>explor</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>explor</h2>

<p><code>explor</code> est un package R qui permet l&#39;exploration &ldquo;interactive&rdquo; des résultats d&#39;une analyse exploratoire multidimensionnelle.</p>

<p>Pour le moment il est utilisable avec les types d&#39;analyses suivants :</p>

<table><thead>
<tr>
<th>Méthode</th>
<th>Fonction</th>
<th>Package</th>
<th>Notes</th>
</tr>
</thead><tbody>
<tr>
<td>Analyse en composantes principales</td>
<td>PCA</td>
<td><a href="http://factominer.free.fr/">FactoMineR</a></td>
<td>-</td>
</tr>
<tr>
<td>Analyse des correspondances</td>
<td>CA</td>
<td><a href="http://factominer.free.fr/">FactoMineR</a></td>
<td>-</td>
</tr>
<tr>
<td>Analyse des correspondances multiples</td>
<td>MCA</td>
<td><a href="http://factominer.free.fr/">FactoMineR</a></td>
<td>-</td>
</tr>
<tr>
<td>Analyse en composantes principales</td>
<td>dudi.pca</td>
<td><a href="https://cran.r-project.org/package=ade4">ade4</a></td>
<td>Les variables supplémentaires qualitatives ne sont pas prises en charge</td>
</tr>
<tr>
<td>Analyse des correspondances</td>
<td>dudi.coa</td>
<td><a href="https://cran.r-project.org/package=ade4">ade4</a></td>
<td>-</td>
</tr>
<tr>
<td>Analyse des correspondances multiples</td>
<td>dudi.acm</td>
<td><a href="https://cran.r-project.org/package=ade4">ade4</a></td>
<td>Les variables supplémentaires quantitatives ne sont pas prises en charge</td>
</tr>
<tr>
<td>Analyse des correspondances multiples spécifique</td>
<td>speMCA</td>
<td><a href="https://cran.r-project.org/package=GDAtools">GDAtools</a></td>
<td>Les variables supplémentaires ne sont pas prises en charge</td>
</tr>
<tr>
<td>Analyse des correspondances multiples</td>
<td>mca</td>
<td><a href="https://cran.r-project.org/package=MASS">MASS</a></td>
<td>Les variables supplémentaires ne sont pas prises en charge</td>
</tr>
<tr>
<td>Analyse en composantes principales</td>
<td>princomp</td>
<td>stats</td>
<td>Les variables supplémentaires ne sont pas prises en charge</td>
</tr>
<tr>
<td>Analyse en composantes principales</td>
<td>prcomp</td>
<td>stats</td>
<td>Les variables supplémentaires ne sont pas prises en charge</td>
</tr>
</tbody></table>

<p>La philosophie d&#39;<code>explor</code> est de n&#39;être qu&#39;une interface de visualisation, et de ne rien &ldquo;exécuter&rdquo; par elle-même. Les analyses et calculs se font dans votre script R, et <code>explor</code> vous aide seulement à visualiser leurs résultats. L&#39;idée est de conserver l&#39;ensemble des commandes dans les scripts et de ne pas risquer d&#39;être un obstacle à la reproductibilité des analyses.</p>

<h2>Fonctionnalités</h2>

<p>Pour chaque méthode, <code>explor</code> lance une interface Web interactive qui s&#39;affiche soit directement dans RStudio, soit dans votre navigateur. Cette interface comprend une série d&#39;onglets présentant différents tableaux et graphiques. Ceux-ci sont, autant que possible, &ldquo;interactifs&rdquo; : les résultats numériques sont affichés sous forme de tableaux dynamiques triables et filtrables (grâce au package <code>DT</code>), et les graphiques, générés pour la plupart par le package <code>scatterD3</code>, ont les fonctionnalités suivantes :</p>

<ul>
<li>zoom avec la molette de la souris</li>
<li>déplacement avec la souris</li>
<li>affichage de <em>tooltips</em> au survol des points</li>
<li>mise en valeur des données correspondantes au survol des items de légendes</li>
<li>étiquettes déplaçables</li>
<li>sélection de points à l&#39;aide d&#39;un outil de type &ldquo;lasso&rdquo;</li>
<li>possibilité d&#39;export du graphique actuel au format SVG</li>
<li>possibilité de récupérer le code R permettant de reproduire le graphique actuel dans un script ou un document</li>
<li>les modifications du graphique se font sous la forme de transitions animées</li>
</ul>

<p>À noter que les interfaces sont traduites en français.</p>

<h2>Utilisation</h2>

<p>L&#39;utilisation du package est très simple : il suffit d&#39;appliquer la fonction <code>explor()</code> à l&#39;objet résultant d&#39;une méthode prise en charge.</p>

<h3><code>prcomp</code>, <code>princomp</code> et <code>MASS::mca</code></h3>

<p>Pour visualiser les résultats de ces fonctions, il suffit de passer l&#39;objet
résultat à <code>explor()</code>.</p>

<p>Voici un exemple avec une ACP réalisée avec <code>princomp</code> :</p>

<pre><code class="r">data(USArrests)
pca &lt;- princomp(USArrests, cor = TRUE)
explor(pca)
</code></pre>

<p><code>explor</code> permet de visualiser des individus supplémentaires dont les
coordonnées ont été calculées avec <code>predict</code>. Il suffit de les ajouter comme
un élément nommé <code>supi</code> de l&#39;objet résultat.</p>

<p>Voici un exemple avec <code>prcomp</code> :</p>

<pre><code class="r">pca &lt;- prcomp(USArrests[6:50,], scale. = TRUE)
pca$supi &lt;- predict(pca, USArrests[1:5,])
explor(pca)
</code></pre>

<p>Pour <code>MASS::mca</code>, <code>explor()</code> permet également la visualisation de variables
qualitatives supplémentaires. Leurs coordonnées doivent être ajoutées comme un
élément nommé <code>supv</code> de l&#39;objet résultat. À noter qu&#39;il est également
préférable d&#39;ajouter manuellement les noms de lignes à l&#39;élément <code>supi</code> car
<code>predict</code> ne les conserve pas :</p>

<pre><code class="r">library(MASS)
mca &lt;- MASS::mca(farms[4:20, 2:4], nf = 11)
supi_df &lt;- farms[1:3, 2:4]
supi &lt;- predict(mca, supi_df, type=&quot;row&quot;)
rownames(supi) &lt;- rownames(supi_df)
mca$supi &lt;- supi
mca$supv &lt;- predict(mca, farms[4:20, 1, drop=FALSE], type=&quot;factor&quot;)
explor(mca)
</code></pre>

<p>À noter que les réultats de ces trois fonctions sont assez limités, elles ne
fournissent que les coordonnées des variables et des individus, pas de
contributions ou de cosinus carrés par exemple.</p>

<h3>Fonctions de <code>FactoMineR</code></h3>

<p>Pour les fonctions de <code>FactoMineR</code>  prises en charge, il suffit de passer l&#39;objet contenant les résultats directement à<code>explor()</code>.</p>

<p>Exemple d&#39;analyse en composantes principales avec <code>FactoMineR::PCA</code> :</p>

<pre><code class="r">library(FactoMineR)
data(decathlon)
pca &lt;- PCA(decathlon[,1:12], quanti.sup = 11:12)
explor(pca)
</code></pre>

<p>Exemple d&#39;analyse des correspondances simples avec <code>FactoMiner::CA</code> :</p>

<pre><code class="r">data(children)
res.ca &lt;- CA(children, row.sup = 15:18, col.sup = 6:8)
explor(res.ca)
</code></pre>

<p>Exemple d&#39;analyse des correspondances multiples avec <code>FactoMineR::MCA</code> :</p>

<pre><code class="r">library(FactoMineR)
data(hobbies)
mca &lt;- MCA(hobbies[1:1000, c(1:8,21:23)], quali.sup = 9:10, 
           quanti.sup = 11, ind.sup = 1:100)
explor(mca)
</code></pre>

<h3>Fonctions d&#39;<code>ade4</code></h3>

<p>Les résultats des fonctions d&#39;<code>ade4</code> prises en charge peuvent également être directement passées à <code>explor()</code>.</p>

<p>Par exemple, pour visualiser les résultats d&#39;une ACP :</p>

<pre><code class="r">library(ade4)
data(deug)
pca &lt;- dudi.pca(deug$tab, scale = TRUE, scannf = FALSE, nf = 5)
explor(pca)
</code></pre>

<p>Des étapes supplémentaires sont nécessaires si on souhaite ajouter des éléments supplémentaires, car <code>ade4</code> ne les inclut pas directement dans l&#39;objet résultat. Il faut donc calculer les coordonnées de ces éléments avec <code>suprow</code> ou <code>supcol</code>, et les ajouter comme éléments <code>supi</code> (pour les individus supplémentaires) ou <code>supv</code> (pour les variables supplémentaires) de l&#39;objet résultat.</p>

<p>Voici un exemple de comment faire tout cela pour une ACP :</p>

<pre><code class="r">data(deug)
d &lt;- deug$tab
sup_var &lt;- d[-(1:10), 8:9]
sup_ind &lt;- d[1:10, -(8:9)]
pca &lt;- dudi.pca(d[-(1:10), -(8:9)], scale = TRUE, scannf = FALSE, nf = 5)
## Individus supplémentaires
supi &lt;- suprow(pca, sup_ind)
pca$supi &lt;- supi$lisup
## Variables supplémentaires
supv &lt;- supcol(pca, dudi.pca(sup_var, scale = TRUE, scannf = FALSE)$tab)
pca$supv &lt;- supv$cosup
explor(pca)
</code></pre>

<p>Il est nécessaire de faire la même chose en cas d&#39;éléments supplémentaires pour une analyse des correspondances multiples :</p>

<pre><code class="r">data(banque)
d &lt;- banque[-(1:100),-(19:21)]
ind_sup &lt;- banque[1:100, -(19:21)]
var_sup &lt;- banque[-(1:100),19:21]
acm &lt;- dudi.acm(d, scannf = FALSE, nf = 5)
## Variables supplémentaires
acm$supv &lt;- supcol(acm, dudi.acm(var_sup, scannf = FALSE, nf = 5)$tab)$cosup
## Individus supplémentaires
acm$supi &lt;- suprow(acm, ind_sup)$lisup
explor(acm)
</code></pre>

<p>Pour une analyse des correspondances simples, on peut afficher des lignes ou colonnes supplémentaires en ajoutant leurs coordonnées à des éléments nommés <code>supr</code> ou <code>supc</code> :</p>

<pre><code class="r">data(bordeaux)
tab &lt;- bordeaux
row_sup &lt;- tab[5,-4]
col_sup &lt;- tab[-5,4]
coa &lt;- dudi.coa(tab[-5,-4], nf = 5, scannf = FALSE)
coa$supr &lt;- suprow(coa, row_sup)$lisup
coa$supc &lt;- supcol(coa, col_sup)$cosup
explor(coa)
</code></pre>

<h3>Fonctions de <code>GDAtools</code></h3>

<p>Les résultats des fonctions de <code>GDAtools</code> prises en charge peuvent également être directement passées à <code>explor()</code>.</p>

<pre><code class="r">library(GDAtools)
data(Music)
mca &lt;- speMCA(Music[,1:5],excl=c(3,6,9,12,15))
explor(mca)
</code></pre>

<p>Pour ajouter des individus supplémentaires, il est nécessaire de calculer leurs données associées à l&#39;aide de la fonction <code>indsup</code>, puis de les ajouter manuellement comme un éléménet nommé <code>supi</code> de l&#39;objet résultat. </p>

<p>Voici un exemple :</p>

<pre><code class="r">library(GDAtools)
data(Music)
mca &lt;- speMCA(Music[3:nrow(Music),1:5],excl=c(3,6,9,12,15))
mca$supi &lt;- indsup(mca,Music[1:2,1:5])
explor(mca)
</code></pre>

<h2>Export des graphiques</h2>

<p><code>explor</code> offre deux possibilités pour exporter les graphiques affichés dans l&#39;interface.</p>

<h3>Export SVG</h3>

<p>Pour exporter le graphique actuellement affiché au format SVG, cliquez sur le bouton <em>Exporter en SVG</em> (icône en bas de la barre latérale gauche), ou choisissez l&#39;entrée <em>Export to SVG</em> du menu &ldquo;engrenage&rdquo; du graphique.</p>

<p>Le SVG est un format de dessin vectoriel, éditable et redimensionnable sans perte à l&#39;aide d&#39;un logiciel comme <a href="https://inkscape.org/">Inkscape</a>.</p>

<p>La fonction d&#39;export SVG peut rencontrer des problèmes quand elle est effectuée depuis RStudio. Si c&#39;est le cas, ouvrez d&#39;abord <code>explor</code> dans un navigateur en cliquant sur <em>Open in Browser</em>, avant d&#39;exporter.</p>

<h3>Récupérer le code R</h3>

<p>L&#39;autre possibilité est de récupérer le code R permettant de générer le graphique actuellement affiché, ce qui permet de le reproduire ensuite dans un script ou un document <em>Rmarkdown</em>.</p>

<p>Pour cela, cliquez sur le bouton <em>Obtenir le code R</em> en bas de la barre latérale. Une boîte de dialogue s&#39;affiche, vous n&#39;avez plus qu&#39;à copier/coller le code R qui s&#39;y trouve.</p>

<p>À noter que ce code R respecte le zoom effectué sur le graphique au moment de l&#39;export, mais pas les positions des labels. Si vous souhaitez conserver celles-ci, il faut d&#39;abord les enregistrer dans un fichier CSV avec l&#39;entrée <em>Export labels positions</em> du menu &ldquo;Engrenage&rdquo;. Ensuite, dans votre script, chargez ce fichier CSV dans un objet à l&#39;aide de <code>read.csv</code> puis passez cet objet à l&#39;argument <code>export_labels_positions</code> dans le code généré :</p>

<pre><code class="r">labels &lt;- read.csv(&quot;position_labels.csv&quot;)
res &lt;- explor::prepare_results(mca)
explor::MCA_var_plot(res, xax = 1, yax = 2,
    var_sup = TRUE, , var_lab_min_contrib = 0,
    col_var = &quot;Variable&quot;, symbol_var = &quot;Type&quot;,
    size_var = NULL, size_range = c(10, 300),
    labels_size = 10, point_size = 56,
    transitions = TRUE, labels_positions = labels)
</code></pre>

<h2>Bugs et commentaires</h2>

<p><code>explor</code> est un package très récent, qui comporte donc certainement des bugs et autres problèmes. N&#39;hésitez pas à les signaler par mail ou en créant une <a href="https://github.com/juba/explor/issues"><em>issue</em> sur GitHub</a>.</p>

</body>

</html>
